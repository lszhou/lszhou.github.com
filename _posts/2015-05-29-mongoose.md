---
layout: post
title: The "M" in "MEAN" full-stack javascript
---

*MEAN* full-stack javascript is popular in today's web application development. It is
short for four javascript-based web technologies:

- *M*: mongoDB -- NoSQL database
- *E*: Express.js -- node.js web application framework
- *A*: AngularJS -- front-end web framework
- *N*: Node.js -- a platform built on Chrome's JavaScript runtime

This series of articles are aimed to list some critical concepts, foundamentals and understanding of this *M*.

---

Although Node.js is supportive to many databases, including mysql, MS sql Server, etc, but as long
as we do some quick google search, it is easy to notice that mongoDB has been the main database choice
for working with Node.js. The reason is straightforward --"fast, flexible and excellent community support".

## schemas and models
MongoDB has not tables and records which are the basic concepts of a traditional relational
database, it is featured by schemas, models, collections, documents.

```javascript
//code snippt for "document"
var user = new User({
	name:'John',
	age:28,
	emial:'hello@world.com'
});
```
So, a document is a set of keys and values. Actually, MongoDB stores documents as BSON, which is effectively binary-encoded JSON.
Everytime when we execute a query operation, we will get a JSON object or a String in JSON formart returned.

> **Analogy**

> From another perspective, the exerience of relational database tells us, the above "ducument" looks like a row (record) in a table.
In this analogy, the key can be thought of as a column.

> however, the important difference is that each document doesn't have to contain the
exact same set of keys, and there is no direct need to have keys with empty values
taking up space.


A collection of documents is called a **collection**. The closest analogy is a table in relational database.
Then, what are schemas and models? a **schema** is fundamentally describing the data construct of a
document. It defines the type of each items/fields, i.e, String, Boolean, ObjectID, etc. In most scenarios you would have one schema for each collection.
A **model** is a compiled version of the schema. One instance of the model will map to one document in the database.

Still use the above code snippt. The first line `var user = new User({` means we create an instance (document) of model `User`.
Similiarily, create a model `User` bassd on the schema `UserSchema` is also one line task:x:

`var User = mongoose.model('User', userSchema);`

## Data types in schemas

The following data types are available in schemas:

- String
- Number
- Date
- Boolean
- Buffer
- ObjectId
- Mixed
- Array

Most of them are easy to master except `ObjectId`.

An `ObjectID` is a unique 12-byte identifier which can be generated by MongoDB as the primary key (`_id`) for a collection. Specifically,
it is a 12-byte BSON type, constructed using:

- a 4-byte value representing the seconds since the Unix epoch,
- a 3-byte machine identifier,
- a 2-byte process id, and
- a 3-byte counter, starting with a random value.

In mongodb official document, it is described as follows:

> In MongoDB, documents stored in a collection require a unique `_id` field that acts as a primary key. Because ObjectIds
are small, most likely unique, and fast to generate, MongoDB uses ObjectIds as the default value for the `_id` field if
the `_id` field is not specified. MongoDB clients should add an `_id` field with a unique ObjectId. However, if a client
does not add an `_id` field, mongod will add an `_id` field that holds an ObjectId.

So sometimes, we have two options. one option is we define the `_id` field ourselves in the schema, for example in the
above `UserSchema`, we define `_id: 123`. Another option is mongodb generate a `_id` field and assign the ObjectID to field `_id` as its value.

So now you may have two questions?

- What is the difference between `ObjectID` and `_id`?
- Why it is called `ObjectID`?

The answer is simple. Because a document in mongodb is actually an instance of a model. In another word, a document `user` is an object of model `User`.
When an obejct (document) is created, mongodb will help create a 12-byte identifier called "ObjectID" automically. The value of `ObjectID` is unique for
each object. When the user doesn't define the `_id` field for the document, the default value of `_id` is the 12-byte identifier.

However, we should be confused by the 12-byte identifier, it is not a String (it is of type ObjectID), if we want to use it as a String, we have to use
the statement `ObjectId("507f191e810c19729de860ea").str`.

ObjectID is very useful in "time stamp" and "embeded document" functionalities. For example, using ObjectIds for the `_id`
field, we can access the creation time of the ObjectId, using the `getTimestamp()` method.

Additionally, The mongo shell provides the `ObjectId()` wrapper class to generate a new ObjectId, and to provide the following
several interesting attributes and methods:

```javascript
//Generate a new ObjectId
//To generate a new ObjectId, use the ObjectId() constructor with no argument:
x = ObjectId()

//In this example, the value of x would be:
ObjectId("507f1f77bcf86cd799439011") //note: the value is not "507f1f77bcf86cd799439011" which is a string.

//To generate a new ObjectId using the ObjectId() constructor with a unique hexadecimal string:
y = ObjectId("507f191e810c19729de860ea")
//In this example, the value of y would be:
ObjectId("507f191e810c19729de860ea")
```



```javascript
//Convert an ObjectId into a Timestamp
//To return the timestamp of an ObjectId() object, use the getTimestamp() method as follows:
ObjectId("507f191e810c19729de860ea").getTimestamp()

//This operation will return the following Date object:
ISODate("2012-10-17T20:46:22Z")
```


```javascript
///Convert ObjectIds into Strings
//Access the str attribute of an ObjectId() object, as follows:
ObjectId("507f191e810c19729de860ea").str

//This operation will return the following hexadecimal string:
507f191e810c19729de860ea

//To return the hexadecimal string representation of an ObjectId(), use the valueOf() method as follows:
ObjectId("507f191e810c19729de860ea").valueOf()
//This operation returns the following output:
507f191e810c19729de860ea

//To return the string representation of an ObjectId() object, use the toString() method as follows:
ObjectId("507f191e810c19729de860ea").toString()

//This operation will return the following output:
ObjectId("507f191e810c19729de860ea")
```

Now we understand the above concepts, let's look at an example:

```javascript
//userSchema
var UserSchema = new Schema({

    username: { type: String, required: true, index:{unique: true} },
    email: { type: String, required: true, index:{unique: true} },
    password: { type: String, required: true, select: false },
    firstName: { type: String, required: true },
    lastName: { type: String, required: true },
    company: { type: String },
    createdOn: { type: Date, default: Date.now },
    lastSignon: { type: Date, default: Date.now},
});

//document output
{
   "username": "Lucy",
   "email": "lucy@email.com",
   "_id": "5563921e50e1659e1172e33b",
   "__v": 0,
   "lastSignon": "2015-05-25T21:20:30.666Z",
   "createdOn": "2015-05-25T21:20:30.666Z"
 }
```

You may find that we did not define `_id`, `__v` in the UserSchema, but in the final document,
we have them. `"_id": "5563921e50e1659e1172e33b",` and `"__v": 0`. I think now we could have a
good understanding of `_id`, yes, it is generated automically with the value ObjectID since we
did not self-define `_id` explicitly. But what the hell is `_v`?

> What's that `__v` thing?

> This is an internal versioning number automatically set by Mongoose when a document is
created. It doesn't increment when a document is changed, but instead is automatically
incremented whenever an array within the document is updated in such a way that
might cause the indexed position of some of the entries to have changed. Why it is needed?

> When working with an array you will typically access the individual elements
through their positional index, for example, myArray[3] . But what happens if
somebody else deletes the element in myArray[2] while you are editing the data
in myArray[3] ? Your original data is now contained in myArray[2] but you
don't know this, so you quite happily overwrite whatever data is now stored in
myArray[3] .The `__v` gives you a method to be able to sanity check this, and prevent
this scenario from happening.

> -- Simon Holmes, "Mongoose for Application Development (2013)"

Up to now, we have looked at how schemas and models relate to our data.
and we should now understand the roles of both schemas and models.

Hopefully, in the next mongodb article, we are going to see how to manipulate you data by the
schemas and models stuff, i.e, how to create, read, update, and delete data.
